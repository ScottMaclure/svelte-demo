{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\src\\SvelteDemoApp.html",
    "..\\src\\Filters.html",
    "..\\src\\Users.html"
  ],
  "sourcesContent": [
    "<:Window on:popstate='doPopState(event)'/>\n\n<div class=\"helloWorld\">\n\n  <nav class=\"navLinks\">\n    <a href=\"#{{routes.splash}}\" on:click='doRoute()'>Home</a>\n    <a href=\"#{{routes.listUsers}}\" on:click='doRoute()'>List Users</a>\n    <a href=\"#{{routes.testBroken}}\" on:click='doRoute()'>Test Broken</a>\n  </nav>\n\n  {{#if route === routes.splash}}\n\n    <Splash name='{{name}}' count='{{count}}'/>\n\n  {{elseif route === routes.listUsers}}\n\n    <ListUsers\n      isLoading='{{isLoading}}'\n      items='{{items}}'\n      sorting='{{sorting}}'\n      filter='{{filter}}'\n      on:filterData='fire(\"filterData\", event)'\n      on:requestData='requestData()'\n      on:editItem='editItem(event)'\n      on:deleteItem='fire(\"deleteItem\", event)'\n      on:updateSorting='fire(\"updateSorting\", event)'\n    />\n\n  {{elseif route === routes.editUser}}\n\n      <EditUser\n        item='{{itemToEdit}}'\n      />\n\n  {{else}}\n\n    <p>No route found for '{{route}}'</p>\n\n  {{/if}}\n\n</div>\n\n<script>\n  import Config from './config.js'\n  import Splash from './Splash.html'\n  import ListUsers from './ListUsers.html'\n  import EditUser from './EditUser.html'\n\n  const getRouteParts = (href) => {\n    // Break up Foo/bar/blah/etc/1 into parts. Individual routes know how to read their own subroutes.\n    return (href || location.hash.slice(1) || Config.routes.default).split('/')\n  }\n\n  export default {\n    components: {\n      Config,\n      Splash,\n      ListUsers,\n      EditUser\n    },\n    // oncreate () {\n    //   this.set({ routeParts: getRouteParts() }) // Set initial view.\n    // },\n    data () {\n      return {\n        routeParts: getRouteParts(),\n        routes: Config.routes,\n        isLoading: false,\n        count: 0,\n        items: [],\n        filter: '',\n        sorting: {} // TODO Defining data structures at multiple levels...\n      }\n    },\n    computed: {\n      route: (routeParts) => {\n        if (!routeParts) {\n          return Config.routes.default // defensive?\n        }\n        return routeParts[0] // the zero-eth part is always the main \"view\" of the route.\n      },\n      itemToEdit: (items, routeParts) => {\n        // routeParts should always be defined due to oncreate method already running?\n        let foundItem = items.find(item => {\n          return item.id.toString() === routeParts[1] // See editItem.\n        })\n        return foundItem || {}\n      }\n    },\n    methods: {\n        /**\n         * Handles events triggered from a) dom nodes or b) semantic events fire'd components.\n         */\n        doRoute: function (event) {\n          if (event.preventDefault) { event.preventDefault() } // semantic events won't have dom events... why should this be here then?\n          let href = event.target ? event.target.getAttribute('href') : event.href // remove hash from href attributes\n          let routeParts = getRouteParts(href) // for semantic events\n          window.history.pushState(routeParts, routeParts[0], ('#' + href)) // FIXME Adding the hash here...\n          this.set({ routeParts: routeParts })\n        },\n        doPopState: function () {\n          // TODO Repeated code from main.js.\n          let routeParts = getRouteParts()\n          this.set({ routeParts: routeParts })\n        },\n        editItem: function (event) {\n          // So, this means that Users component knows nothing about route generation, it just fired up the id.\n          this.doRoute({ href: Config.routes.editUser+'/'+event.id }) // FIXME weaksauce route url construction.\n        },\n        requestData: function () {\n          // TODO isLoading... localise to Users component?\n          this.set({ isLoading: true })\n          this.fire('requestData')\n        },\n        setData: function (data) {\n          data.isLoading = false\n          data.originalItems = data.items.slice() // make a shallow copy for filtering etc.\n          this.set(data)\n        }\n    }\n  }\n</script>\n<style>\n  .helloWorld {\n    background-color: var(--base-background-color, #00f);\n    padding: var(--spacing-vertical-normal);\n  }\n  .navLinks a {\n    margin-right: var(--spacing-horizontal-small);\n  }\n</style>",
    "<div class=\"filters\">\n    <label for=\"filter\">Filter:</label>\n    <input type=\"text\" id=\"filter\" name=\"filter\" value=\"{{filter}}\" on:keyup='possibleFilter(event)'/>\n</div>\n<script>\n    const FILTER_WAIT = 250\n\n    var timer;\n\n    export default {\n        data () {\n            return {\n                filter: ''\n            }\n        },\n        methods: {\n            /**\n             * Only fire after a certain number of characters have been typed.\n             * Wait before firing the event, to debounce.\n             */\n            possibleFilter: function (event) {\n                var self = this\n\n                window.clearTimeout(timer)\n\n                let filterValue = event.target.value.trim();\n\n                // TODO MIN_FILTER_LENGTH check here, but how to handle delete actions?\n\n                timer = setTimeout(function () {\n                    self.fire('filterData', { filter: filterValue })\n                }, FILTER_WAIT);\n\n            }\n        }\n    }\n</script>\n<style>\n    .filters {\n        margin: var(--spacing-vertical-normal) 0;\n    }\n</style>",
    "<div class=\"users\">\n    <table border=\"1\" width=\"100%\">\n\n        <thead>\n            <th><a href=\"#\" on:click='sortItems(event, { fieldName: \"id\" })'>Id {{getSortIcon('id', sorting, utfShapes)}}</a></th>\n            <th><a href=\"#\" on:click='sortItems(event, { fieldName: \"firstName\" })'>First Name {{getSortIcon('firstName', sorting, utfShapes)}}</a></th>\n            <th><a href=\"#\" on:click='sortItems(event, { fieldName: \"lastName\" })'>Last Name {{getSortIcon('lastName', sorting, utfShapes)}}</a></th>\n            <th><a href=\"#\" on:click='sortItems(event, { fieldName: \"email\" })'>Email {{getSortIcon('email', sorting, utfShapes)}}</a></th>\n            <th>Actions</th>\n        </thead>\n\n        <tbody>\n            {{#if items && items.length > 0}}\n                {{#each processedItems as item}}\n                    <tr>\n                        <td>{{item.id}}</td>\n                        <td>{{item.firstName}}</td>\n                        <td>{{item.lastName}}</td>\n                        <td>{{item.email}}</td>\n                        <td>\n                            <i class=\"noselect\" on:click='fire(\"editItem\", { id: item.id })'>{{unicodes.edit}}</i>\n                            <i class=\"noselect\" on:click='fire(\"deleteItem\", { id: item.id })'>{{unicodes.delete}}</i>\n                        </td>\n                    </tr>\n                {{/each}}\n            {{else}}\n                <tr>\n                    <td colspan=\"5\">\n                        {{#if isLoading}}\n                            <span class=\"loading\">Loading...</span> {{else}} No rows present.\n                            <button on:click='fire(\"requestData\")'>Load</button>\n                        {{/if}}\n                    </td>\n                </tr>\n            {{/if}}\n        </tbody>\n\n    </table>\n</div>\n\n<script>\n    import Config from './config.js'\n\n    export default {\n        data() {\n            return {\n                unicodes: Config.unicodes,\n                isLoading: false,\n                items: [],\n                sorting: {\n                    active: true,\n                    fieldName: 'id',\n                    order: 'asc'\n                },\n                utfShapes: {\n                    invis: '\\u2063',\n                    asc: '\\u25B4',\n                    desc: '\\u25BE'\n                }\n            }\n        },\n        computed: {\n            /**\n             * TODO What's more efficient - computed property or a methods function?\n             */\n            processedItems: (items, sorting) => (\n                items.sort((a, b) => {\n                    let aV = a[sorting.fieldName]\n                    let bV = b[sorting.fieldName]\n                    if (aV === bV) { return 0; } // same value\n                    // asc is default also.\n                    let [lessThan, greaterThan] = (sorting.order === 'desc') ? [1, -1] : [-1, 1]\n                    return (aV < bV) ? lessThan : greaterThan\n                })\n            )\n        },\n        helpers: {\n            /**\n             * Not a computed property - helper function with passed-in data context.\n             */\n            getSortIcon: function (fieldName, sorting, utfShapes) {\n                if (!sorting.active) { return utfShapes.invis }\n                if (sorting.fieldName !== fieldName) { return utfShapes.invis }\n                // TODO per-field sorting values etc.\n                return utfShapes[sorting.order]\n            }\n        },\n        methods: {\n            /**\n             * When user changes sorting we only update the \"sorting\" meta-data.\n             * The actual sorting happens as a computed property (processedItems).\n             */\n            sortItems: function(event, params) {\n                event.preventDefault();\n                this.fire('updateSorting', params)\n            }\n        }\n    }\n</script>\n\n<style type=\"text/css\">\n    .users {\n        overflow: auto;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "AA0HO;EACL,+DAAW,CAAC;IACV,iBAAiB,CAAC,IAAI,uBAAuB,CAAC,KAAK,CAAC;IACpD,QAAQ,CAAC,IAAI,yBAAyB,CAAC;GACxC;EACD,+DAAW,CAAC;IACV,aAAa,CAAC,IAAI,0BAA0B,CAAC;GAC9C;AACH;AC7FO;IACH,yDAAQ,CAAC;QACL,OAAO,CAAC,IAAI,yBAAyB,CAAC,CAAC,CAAC;KAC3C;AACL;AC2DO,MAAM,QAAQ,CAAC;IAClB,qDAAM,CAAC;QACH,SAAS,CAAC,IAAI;KACjB;AACL"
}