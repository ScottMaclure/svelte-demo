{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\src\\SvelteDemoApp.html",
    "..\\src\\Filters.html",
    "..\\src\\Users.html",
    "..\\src\\EditUser.html"
  ],
  "sourcesContent": [
    "<:Window on:popstate='doPopState(event)'/>\n\n<div class=\"helloWorld\">\n\n  <!-- TODO refactor into component -->\n  {{#if messages.length > 0}}\n    <div class=\"messages\">\n      {{#each messages as message}}\n        <div class=\"alert alert-{{message.type}}\">\n          <div>{{message.title}}</div>\n          <div>{{message.content}}</div>\n        </div>\n      {{/each}}\n    </div>\n  {{/if}}\n\n  <h1>Svelte Demo App</h1>\n\n  <nav class=\"navLinks\">\n    <a href=\"#{{routes.splash}}\" on:click='doRoute(event)'>Home</a>\n    <a href=\"#{{routes.listUsers}}\" on:click='doRoute(event)'>List Users</a>\n    <a href=\"#{{routes.testBroken}}\" on:click='doRoute(event)'>Test Broken</a>\n  </nav>\n\n  {{#if route === routes.splash}}\n\n    <Splash name='{{name}}' count='{{count}}'/>\n\n  {{elseif route === routes.listUsers}}\n\n    <ListUsers\n      isLoading='{{isLoading}}'\n      items='{{items}}'\n      sorting='{{sorting}}'\n      filter='{{filter}}'\n      on:filterData='fire(\"filterData\", event)'\n      on:requestData='requestData()'\n      on:editItem='editItem(event)'\n      on:deleteItem='fire(\"deleteItem\", event)'\n      on:updateSorting='fire(\"updateSorting\", event)'\n    />\n\n  {{elseif route === routes.editUser}}\n\n      <EditUser\n        items='{{items}}'\n        item='{{itemToEdit}}'\n        on:requestData='requestData()'\n        on:cancelEdit='cancelEdit(event)'\n        on:saveUser='fire(\"saveUser\", event)'\n      />\n\n  {{else}}\n\n    <p>No route found for '{{route}}'</p>\n\n  {{/if}}\n\n</div>\n\n<script>\n  import Config from './config.js'\n  import Splash from './Splash.html'\n  import ListUsers from './ListUsers.html'\n  import EditUser from './EditUser.html'\n\n  const getRouteParts = (href) => {\n    // Break up Foo/bar/blah/etc/1 into parts. Individual routes know how to read their own subroutes.\n    return (href || location.hash.slice(1) || Config.routes.default).split('/')\n  }\n\n  export default {\n    components: {\n      Config,\n      Splash,\n      ListUsers,\n      EditUser\n    },\n    // oncreate () {\n    //   // this.set({ routeParts: getRouteParts() }) // Set initial view. (default data removes need for this.)\n    //   console.log('SvelteDemoApp oncreate')\n    // },\n    data () {\n      return {\n        routeParts: getRouteParts(),\n        routes: Config.routes,\n        isLoading: false,\n        messages: [],\n        count: 0,\n        items: [],\n        filter: '',\n        sorting: {} // TODO Defining data structures at multiple levels...\n      }\n    },\n    computed: {\n      route: (routeParts) => {\n        if (!routeParts) {\n          return Config.routes.default // defensive?\n        }\n        return routeParts[0] // the zero-eth part is always the main \"view\" of the route.\n      },\n      itemToEdit: (items, routeParts) => {\n        // routeParts should always be defined due to oncreate method already running?\n        let foundItem = items.find(item => {\n          return item.id.toString() === routeParts[1] // See editItem.\n        })\n        return foundItem || {}\n      }\n    },\n    methods: {\n        /**\n         * Handles events triggered from a) dom nodes or b) semantic events fire'd components.\n         */\n        doRoute: function (event) {\n          if (event.preventDefault) { event.preventDefault() } // semantic events won't have dom events... why should this be here then?\n          let href = event.target ? event.target.getAttribute('href').slice(1) : event.href // remove hash from href attributes\n          let routeParts = getRouteParts(href) // for semantic events\n          window.history.pushState(routeParts, routeParts[0], ('#' + href)) // FIXME Adding the hash here...\n          this.set({ routeParts: routeParts })\n        },\n        doPopState: function () {\n          // TODO Repeated code from main.js.\n          let routeParts = getRouteParts()\n          this.set({ routeParts: routeParts })\n        },\n        editItem: function (event) {\n          // TODO Could check for populated items array at this point?\n          // So, this means that Users component knows nothing about route generation, it just fired up the id.\n          this.doRoute({ href: Config.routes.editUser+'/'+event.id }) // FIXME weaksauce route url construction.\n        },\n        cancelEdit: function () {\n          this.doRoute({ href: Config.routes.listUsers})\n        },\n        requestData: function () {\n          // TODO isLoading... localise to Users component?\n          this.set({ isLoading: true })\n          this.fire('requestData')\n        },\n        setData: function (data) {\n          data.isLoading = false\n          data.originalItems = data.items.slice() // make a shallow copy for filtering etc.\n          this.set(data)\n        }\n    }\n  }\n</script>\n<style>\n  .helloWorld {\n    padding: var(--spacing-vertical-normal);\n  }\n  .helloWorld nav {\n    margin-bottom: var(--spacing-vertical-normal);\n  }\n  .helloWorld .navLinks a {\n    margin-right: var(--spacing-horizontal-small);\n  }\n  .messages {\n    position: fixed;\n    top: var(--spacing-vertical-small);\n    width: 95%;\n  }\n</style>",
    "<div class=\"filters\">\n    <label for=\"filter\">Filter:</label>\n    <input type=\"text\" id=\"filter\" name=\"filter\" value=\"{{filter}}\" on:keyup='possibleFilter(event)'/>\n</div>\n<script>\n    const FILTER_WAIT = 250\n\n    var timer;\n\n    export default {\n        data () {\n            return {\n                filter: ''\n            }\n        },\n        methods: {\n            /**\n             * Only fire after a certain number of characters have been typed.\n             * Wait before firing the event, to debounce.\n             */\n            possibleFilter: function (event) {\n                var self = this\n\n                window.clearTimeout(timer)\n\n                let filterValue = event.target.value.trim();\n\n                // TODO MIN_FILTER_LENGTH check here, but how to handle delete actions?\n\n                timer = setTimeout(function () {\n                    self.fire('filterData', { filter: filterValue })\n                }, FILTER_WAIT);\n\n            }\n        }\n    }\n</script>\n<style>\n    .filters {\n        margin: var(--spacing-vertical-normal) 0;\n    }\n</style>",
    "<div class=\"users\">\n    <table class=\"table-striped\">\n\n        <thead>\n            <th><a href=\"#\" on:click='sortItems(event, { fieldName: \"id\" })'>Id {{getSortIcon('id', sorting, utfShapes)}}</a></th>\n            <th><a href=\"#\" on:click='sortItems(event, { fieldName: \"firstName\" })'>First Name {{getSortIcon('firstName', sorting, utfShapes)}}</a></th>\n            <th><a href=\"#\" on:click='sortItems(event, { fieldName: \"lastName\" })'>Last Name {{getSortIcon('lastName', sorting, utfShapes)}}</a></th>\n            <th><a href=\"#\" on:click='sortItems(event, { fieldName: \"email\" })'>Email {{getSortIcon('email', sorting, utfShapes)}}</a></th>\n            <th>Actions</th>\n        </thead>\n\n        <tbody>\n            {{#if items && items.length > 0}}\n                {{#each processedItems as item}}\n                    <tr>\n                        <td><a href=\"#\" on:click='doEditItem(event, item)'>{{item.id}}</a></td>\n                        <td>{{item.firstName}}</td>\n                        <td>{{item.lastName}}</td>\n                        <td>{{item.email}}</td>\n                        <td>\n                            <i class=\"noselect\" on:click='doEditItem(event, item)'>{{unicodes.edit}}</i>\n                            <i class=\"noselect\" on:click='fire(\"deleteItem\", { id: item.id })'>{{unicodes.delete}}</i>\n                        </td>\n                    </tr>\n                {{/each}}\n            {{else}}\n                <tr>\n                    <td colspan=\"5\">\n                        {{#if isLoading}}\n                            <span class=\"loader\"></span>\n                        {{else}} No rows present.\n                            <button on:click='fire(\"requestData\")'>Load</button>\n                        {{/if}}\n                    </td>\n                </tr>\n            {{/if}}\n        </tbody>\n\n    </table>\n</div>\n\n<script>\n    import Config from './config.js'\n\n    export default {\n        data() {\n            return {\n                unicodes: Config.unicodes,\n                isLoading: false,\n                items: [],\n                sorting: {\n                    active: true,\n                    fieldName: 'id',\n                    order: 'asc'\n                },\n                utfShapes: {\n                    invis: '\\u2063',\n                    asc: '\\u25B4',\n                    desc: '\\u25BE'\n                }\n            }\n        },\n        computed: {\n            /**\n             * TODO What's more efficient - computed property or a methods function?\n             */\n            processedItems: (items, sorting) => (\n                items.sort((a, b) => {\n                    let aV = a[sorting.fieldName]\n                    let bV = b[sorting.fieldName]\n                    if (aV === bV) { return 0; } // same value\n                    // asc is default also.\n                    let [lessThan, greaterThan] = (sorting.order === 'desc') ? [1, -1] : [-1, 1]\n                    return (aV < bV) ? lessThan : greaterThan\n                })\n            )\n        },\n        helpers: {\n            /**\n             * Not a computed property - helper function with passed-in data context.\n             */\n            getSortIcon: function (fieldName, sorting, utfShapes) {\n                if (!sorting.active) { return utfShapes.invis }\n                if (sorting.fieldName !== fieldName) { return utfShapes.invis }\n                // TODO per-field sorting values etc.\n                return utfShapes[sorting.order]\n            }\n        },\n        methods: {\n            /**\n             * When user changes sorting we only update the \"sorting\" meta-data.\n             * The actual sorting happens as a computed property (processedItems).\n             */\n            sortItems: function(event, params) {\n                event.preventDefault();\n                this.fire('updateSorting', params)\n            },\n            doEditItem: function (event, item) {\n                event.preventDefault()\n                this.fire('editItem', { id: item.id })\n            }\n        }\n    }\n</script>\n\n<style>\n    .users {\n        overflow: scroll;\n    }\n</style>",
    "<div class=\"editUser\">\n  {{#if isLoading}}\n    <span class=\"loader\"></span>\n  {{else}}\n    <!-- TODO new vs edit -->\n    <form on:submit=\"saveUser(event)\">\n      <fieldset>\n        <legend>Edit User #{{item.id}}</legend>\n        <input type=\"hidden\" name=\"id\" value=\"{{item.id}}\">\n\n        <div class=\"row\">\n          <label for=\"firstName\">First name</label>\n          <input ref:firstName name=\"firstName\" type=\"text\" placeholder=\"e.g. Bob\" value=\"{{item.firstName}}\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"lastName\">Last name</label>\n          <input ref:lastName name=\"lastName\" type=\"text\" placeholder=\"e.g. Connor\" value=\"{{item.lastName}}\">\n        </div>\n\n        <div class=\"row\">\n          <label for=\"email\">Email</label>\n          <input ref:email name=\"email\" type=\"email\" placeholder=\"bob@connor.com\" value=\"{{item.email}}\">\n        </div>\n\n        <div class=\"row\">\n          <button type=\"submit\" class=\"button\">Save</button>\n          <a href=\"#\" on:click=\"cancelEdit(event)\">Cancel</a>\n        </div>\n\n      </fieldset>\n\n    </form>\n  {{/if}}\n</div>\n<script>\n\n  import isEqual from 'lodash.isequal'\n\n  export default {\n    data () {\n      return {\n        isLoading: false, // TODO What about passing this in>\n        item: {},\n        items: []\n      }\n    },\n    oncreate () {\n\n      // Some trickery so that if the items haven't been loaded yet, trigger that request and, once done, update the component's state.\n      if (this.get('items').length === 0) {\n        var self = this\n        this.set({ isLoading: true })\n\n        let observer = null;\n        observer = this.observe('items', () => {\n          self.set({ isLoading: false })\n          observer.cancel()\n        }, { init: false })\n\n        // FIXME Hack because main.js use of app.on() for requestData is bound after app is finished being created!\n        setTimeout(() => {\n          self.fire('requestData')\n        }, 250)\n\n      }\n    },\n    methods: {\n      /**\n       * TODO Best practice here? Two-way bindings for convenience?\n       */\n      saveUser: function (event) {\n        event.preventDefault()\n\n        // TODO validate a user item, return a payload the UI can use. Standardise.\n\n        let item = this.get('item') // original item\n\n        let editItem = JSON.parse(JSON.stringify(this.get('item')))\n        editItem.firstName = this.refs.firstName.value\n        editItem.lastName = this.refs.lastName.value\n        editItem.email = this.refs.email.value\n\n        // Check any fields were actually changed first.\n        if (isEqual(item, editItem)) {\n          return\n        }\n\n        // Changed\n        this.fire('saveUser', editItem)\n      },\n      /**\n       * Interesting.. don't put routing knowledge into this component, just fire the semantic event and let the \"app\" take care of it.\n       * Keeps routing within the app component, rather than scattered throughout the subcomponents?\n       */\n      cancelEdit: function (event) {\n        event.preventDefault()\n        this.fire('cancelEdit', event)\n      }\n    }\n  }\n</script>\n\n<style>\n  .editUser label {\n    display: block;\n  }\n  .editUser .row {\n    margin-bottom: var(--spacing-vertical-small);\n  }\n  .editUser input[type=text], .editUser input[type=email] {\n    width: 100%;\n    max-width: var(--max-width-normal);\n  }\n</style>"
  ],
  "names": [],
  "mappings": "AAkJO;EACL,6DAAW,CAAC;IACV,QAAQ,CAAC,IAAI,yBAAyB,CAAC;GACxC;EACD,qEAAe,CAAC;IACd,cAAc,CAAC,IAAI,yBAAyB,CAAC;GAC9C;EACD,qFAAuB,CAAC;IACtB,aAAa,CAAC,IAAI,0BAA0B,CAAC;GAC9C;EACD,yDAAS,CAAC;IACR,SAAS,CAAC,KAAK;IACf,IAAI,CAAC,IAAI,wBAAwB,CAAC;IAClC,MAAM,CAAC,GAAG;GACX;AACH;AC5HO;IACH,yDAAQ,CAAC;QACL,OAAO,CAAC,IAAI,yBAAyB,CAAC,CAAC,CAAC;KAC3C;AACL;ACgEO;IACH,mDAAM,CAAC;QACH,SAAS,CAAC,MAAM;KACnB;AACL;ACNO;EACL,uEAAe,CAAC;IACd,QAAQ,CAAC,KAAK;GACf;EACD,qEAAc,CAAC;IACb,cAAc,CAAC,IAAI,wBAAwB,CAAC;GAC7C;EACD,6FAA0B,EAAE,+FAA2B,CAAC;IACtD,MAAM,CAAC,IAAI;IACX,UAAU,CAAC,IAAI,kBAAkB,CAAC;GACnC;AACH"
}